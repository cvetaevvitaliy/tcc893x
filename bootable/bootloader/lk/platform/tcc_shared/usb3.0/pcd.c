/* ==========================================================================
 * $File: //dwh/usb_iip/dev/software/DWC_usb3/driver/pcd.c $
 * $Revision: #96 $
 * $Date: 2012/01/23 $
 * $Change: 1924659 $
 *
 * Synopsys SS USB3 Linux Software Driver and documentation (hereinafter,
 * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
 * otherwise expressly agreed to in writing between Synopsys and you.
 *
 * The Software IS NOT an item of Licensed Software or Licensed Product under
 * any End User Software License Agreement or Agreement for Licensed Product
 * with Synopsys or any supplement thereto. You are permitted to use and
 * redistribute this Software in source and binary forms, with or without
 * modification, provided that redistributions of source code must retain this
 * notice. You may not view, use, disclose, copy or distribute this file or
 * any information contained herein except pursuant to this license grant from
 * Synopsys. If you do not agree with this notice, including the disclaimer
 * below, then you are not authorized to use the Software.
 *
 * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 * ========================================================================== */

/** @file
 * This file implements the Peripheral Controller Driver.
 *
 * The Peripheral Controller Driver (PCD) is responsible for translating
 * requests from the Function Driver into the appropriate actions on the
 * DWC_usb3 controller. It isolates the Function Driver from the specifics
 * of the controller by providing an API to the Function Driver.
 *
 * The Peripheral Controller Driver for Linux will implement the Gadget API,
 * so that the existing Gadget drivers can be used. (Gadget Driver is the
 * Linux terminology for a Function Driver.)
 *
 * The Linux Gadget API is defined in the header file
 * <code><linux/usb/gadget.h></code>. The USB EP operations API is defined
 * in the structure <code>usb_ep_ops</code> and the USB Controller API is
 * defined in the structure <code>usb_gadget_ops</code>.
 *
 * An important function of the PCD is managing interrupts generated by the
 * DWC_usb3 controller. The implementation of the DWC_usb3 device mode
 * interrupt service routines is in pcd_intr.c.
 */
/*
 * todo  Add Device Mode test modes (Test J mode, Test K mode, etc).
 */
#include "usb3.0/os_dep.h"
#include "usb3.0/hw.h"
#include "usb3.0/usb.h"
#include "usb3.0/pcd.h"
#include "usb3.0/driver.h"
#include "usb3.0/cil.h"
#define pcd_debug(f, a...)    		dprintf(2,"" f, ##a) 

#ifdef DWC_UTE
# include "ute_if.h"
#endif

/**
 * This function gets the DMA descriptor (TRB) for a data transfer and stores
 * it in the given request. Called from the core code.
 *
 * @param pcd    Programming view of DWC_usb3 peripheral controller.
 * @param ep     The EP for the transfer.
 * @param req    The request that needs the TRB.
 */
void dwc_usb3_os_get_trb(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			 dwc_usb3_pcd_req_t *req)
{
	dwc_usb3_dma_desc_t *desc;
	dma_addr_t desc_dma;

	dwc_debug(pcd->usb3_dev, "%s()\n", __func__);

	/* If EP0, fill request with EP0 IN/OUT data TRB */
	if (ep == pcd->ep0) {
		if (ep->dwc_ep.is_in) {
			req->dwc_req.trb = pcd->ep0_in_desc;
			req->dwc_req.trbdma = pcd->ep0_in_desc_dma;
		} else {
			req->dwc_req.trb = pcd->ep0_out_desc;
			req->dwc_req.trbdma = pcd->ep0_out_desc_dma;
		}
	/* Else fill request with TRB from the non-EP0 allocation */
	} else if (!req->dwc_req.trb) {
		/* Get the next DMA Descriptor (TRB) for this EP */
		desc = (dwc_usb3_dma_desc_t *)
			(ep->dwc_ep.dma_desc + ep->dwc_ep.desc_idx
						* req->dwc_req.numbuf * 16);
		desc_dma = (dma_addr_t)
			((unsigned long)ep->dwc_ep.dma_desc_dma +
			 (unsigned long)ep->dwc_ep.desc_idx
						* req->dwc_req.numbuf * 16);

		if (++ep->dwc_ep.desc_idx >= ep->dwc_ep.num_desc)
			ep->dwc_ep.desc_idx = 0;
		ep->dwc_ep.desc_avail--;

		req->dwc_req.trb = desc;
		req->dwc_req.trbdma = desc_dma;
	}
}

/**
 * This function configures EP0 OUT to receive SETUP packets and configures
 * EP0 IN for transmitting packets.
 *
 * @param pcd Programming view of DWC_usb3 peripheral controller.
 */
void dwc_usb3_ep0_activate(dwc_usb3_pcd_t *pcd, int restore)
{
	unsigned int diepcfg0, doepcfg0, diepcfg1, doepcfg1;
	unsigned int diepcfg2 = 0, doepcfg2 = 0;
	dwc_usb3_dev_ep_regs_t   *ep_reg;

	pcd_debug( "%s()\n", __func__);
	
	diepcfg0 = DWC_USB3_EP_TYPE_CONTROL << DWC_EPCFG0_EPTYPE_SHIFT;
	diepcfg1 = DWC_EPCFG1_XFER_CMPL_BIT | DWC_EPCFG1_XFER_IN_PROG_BIT |
		   DWC_EPCFG1_XFER_NRDY_BIT | DWC_EPCFG1_EP_DIR_BIT;

	doepcfg0 = DWC_USB3_EP_TYPE_CONTROL << DWC_EPCFG0_EPTYPE_SHIFT;
	doepcfg1 = DWC_EPCFG1_XFER_CMPL_BIT | DWC_EPCFG1_XFER_IN_PROG_BIT |
		   DWC_EPCFG1_XFER_NRDY_BIT;

	/* Default to MPS of 512 (will reconfigure after ConnectDone event) */
	diepcfg0 |= 512 << DWC_EPCFG0_MPS_SHIFT;
	doepcfg0 |= 512 << DWC_EPCFG0_MPS_SHIFT;

#ifdef DWC_UTE
	pcd->ep0->dwc_ep.tx_fifo_num = pcd->txf_map[1];
#endif
	diepcfg0 |= pcd->ep0->dwc_ep.tx_fifo_num << DWC_EPCFG0_TXFNUM_SHIFT;

	if (restore) {
		diepcfg0 |= DWC_CFG_ACTION_RESTORE
					<< DWC_EPCFG0_CFG_ACTION_SHIFT;
		diepcfg2 = pcd->ep0_in_save_state;
		pcd_debug( "IN restore state=%08x\n", diepcfg2);
		doepcfg0 |= DWC_CFG_ACTION_RESTORE
					<< DWC_EPCFG0_CFG_ACTION_SHIFT;
		doepcfg2 = pcd->ep0_out_save_state;
		pcd_debug( "OUT restore state=%08x\n", doepcfg2);
	}

	/*
	 * Issue "DEPCFG" command to EP0-OUT
	 */

	ep_reg = &pcd->out_ep_regs[0];

	/* If core is version 1.09a or later */
	if ((pcd->usb3_dev->snpsid & 0xffff) >= 0x109a) {
		/* Must issue DEPSTRTNEWCFG command first */
		dwc_usb3_dep_startnewcfg(pcd, ep_reg, 0);
	}

	dwc_usb3_dep_cfg(pcd, ep_reg, doepcfg0, doepcfg1, doepcfg2);

	/*
	 * Issue "DEPSTRMCFG" command to EP0-OUT
	 */

	/* One stream */
	dwc_usb3_dep_xfercfg(pcd, ep_reg, 1);

	/*
	 * Issue "DEPCFG" command to EP0-IN
	 */

	ep_reg = &pcd->in_ep_regs[0];
	dwc_usb3_dep_cfg(pcd, ep_reg, diepcfg0, diepcfg1, diepcfg2);

	/*
	 * Issue "DEPSTRMCFG" command to EP0-IN
	 */

	/* One stream */
	dwc_usb3_dep_xfercfg(pcd, ep_reg, 1);

	pcd->ep0->dwc_ep.active = 1;
}

/**
 * This function activates an EP. The Device EP control registers for the EP
 * are configured as defined in the EP structure.
 *
 * @param pcd     Programming view of DWC_usb3 peripheral controller.
 * @param ep      The EP to activate.
 * @param restore True if restoring endpoint state after hibernate.
 */
void dwc_usb3_ep_activate(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			  int restore)
{
	dwc_usb3_dev_ep_regs_t   *ep_reg, *ep0_reg;
	unsigned int depcfg0, depcfg1, depcfg2 = 0;

	pcd_debug( "%s() EP%d-%s\n", __func__, ep->dwc_ep.num,
		   (ep->dwc_ep.is_in ? "IN" : "OUT"));

	ep->dwc_ep.hiber_desc_idx = 0;

#ifdef DWC_STAR_9000463548_WORKAROUND
	if (pcd->configuring)
		goto skip;
#endif
	/*
	 * Get the appropriate EP registers
	 */
	if (ep->dwc_ep.is_in)
		ep_reg = ep->dwc_ep.in_ep_reg;
	else
		ep_reg = ep->dwc_ep.out_ep_reg;

	/* If this is first EP enable (ie. start of a new configuration) */
	if (!pcd->eps_enabled) {

#ifdef DWC_STAR_9000463548_WORKAROUND
		dwc_usb3_dev_ep_regs_t   *ept_reg;
		dwc_usb3_pcd_ep_t *ept;
		int i;

		/* For the workaround, we must wait for all EndXfers on all EPs
		 * to complete before continuing
		 */
		for (i = 0; i < pcd->num_in_eps; i++) {
			ept = pcd->in_ep[i];
			dwc_print3(pcd->usb3_dev, "DWC IN EP%d=%p tri-in=%d\n",
				   i, ept, ept->dwc_ep.tri_in);
			if (ept->dwc_ep.tri_in) {
				ept_reg = ept->dwc_ep.in_ep_reg;
				ept->dwc_ep.condition = 0;
				dwc_usb3_dep_wait_endxfer(pcd, ept_reg,
						&ept->dwc_ep.condition);
				ept->dwc_ep.tri_in = 0;
			}
		}

		for (i = 0; i < pcd->num_out_eps; i++) {
			ept = pcd->out_ep[i];
			dwc_print3(pcd->usb3_dev,
				   "DWC OUT EP%d=%p tri-out=%d\n",
				   i, ept, ept->dwc_ep.tri_out);
			if (ept->dwc_ep.tri_out) {
				ept_reg = ept->dwc_ep.out_ep_reg;
				ept->dwc_ep.condition = 0;
				dwc_usb3_dep_wait_endxfer(pcd, ept_reg,
						&ept->dwc_ep.condition);
				ept->dwc_ep.tri_out = 0;
			}
		}
#endif
		pcd->eps_enabled = 1;

		/* NOTE: When setting a new configuration, we must issue a
		 * "DEPCFG" command to physical EP1 (logical EP0-IN) first.
		 * This resets the core's Tx FIFO mapping table
		 */
		depcfg0 = DWC_USB3_EP_TYPE_CONTROL << DWC_EPCFG0_EPTYPE_SHIFT;
		depcfg0 |= DWC_CFG_ACTION_MODIFY << DWC_EPCFG0_CFG_ACTION_SHIFT;
		depcfg1 = DWC_EPCFG1_XFER_CMPL_BIT | DWC_EPCFG1_XFER_IN_PROG_BIT
			| DWC_EPCFG1_XFER_NRDY_BIT | DWC_EPCFG1_EP_DIR_BIT;

		switch (pcd->speed) {
		case USB_SPEED_SUPER:
			depcfg0 |= 512 << DWC_EPCFG0_MPS_SHIFT;
			break;

		case USB_SPEED_HIGH:
		case USB_SPEED_FULL:
			depcfg0 |= 64 << DWC_EPCFG0_MPS_SHIFT;
			break;

		case USB_SPEED_LOW:
			depcfg0 |= 8 << DWC_EPCFG0_MPS_SHIFT;
			break;
		}

		ep0_reg = &pcd->in_ep_regs[0];

		dwc_usb3_dep_cfg(pcd, ep0_reg, depcfg0, depcfg1, 0);

		/* If core is version 1.09a or later */
		if ((pcd->usb3_dev->snpsid & 0xffff) >= 0x109a) {
			/* Must issue DEPSTRTNEWCFG command first */
			ep0_reg = &pcd->out_ep_regs[0];
			dwc_usb3_dep_startnewcfg(pcd, ep0_reg, 2);
		}
	}

	/*
	 * Issue "DEPCFG" command to EP
	 */
	depcfg0 = ep->dwc_ep.type << DWC_EPCFG0_EPTYPE_SHIFT;
	depcfg0 |= ep->dwc_ep.maxpacket << DWC_EPCFG0_MPS_SHIFT;

	if (ep->dwc_ep.is_in) {
#ifdef DWC_UTE
		ep->dwc_ep.tx_fifo_num = pcd->txf_map[ep->dwc_ep.phys];
#endif
		depcfg0 |= ep->dwc_ep.tx_fifo_num << DWC_EPCFG0_TXFNUM_SHIFT;
	}

	if (pcd->usb3_dev->core_params->burst) {
		pcd_debug( "Setting maxburst to %u\n",
			   ep->dwc_ep.maxburst);
		depcfg0 |= ep->dwc_ep.maxburst << DWC_EPCFG0_BRSTSIZ_SHIFT;
	}

	if (restore) {
		depcfg0 |= DWC_CFG_ACTION_RESTORE
					<< DWC_EPCFG0_CFG_ACTION_SHIFT;
		depcfg2 = ep->dwc_ep.save_state;
	}

	depcfg1 = ep->dwc_ep.num << DWC_EPCFG1_EP_NUM_SHIFT;
	if (ep->dwc_ep.is_in)
		depcfg1 |= DWC_EPCFG1_EP_DIR_BIT;

	depcfg1 |= DWC_EPCFG1_XFER_CMPL_BIT;
	depcfg1 |= DWC_EPCFG1_XFER_IN_PROG_BIT;
	depcfg1 |= DWC_EPCFG1_XFER_NRDY_BIT;
	dwc_isocdbg1(pcd->usb3_dev, "Setting bInterval-1 to %u\n",
		     ep->dwc_ep.intvl);
	depcfg1 |= ep->dwc_ep.intvl << DWC_EPCFG1_BINTERVAL_SHIFT;

#ifdef DWC_UASP_GADGET_STREAMS
	if (ep->dwc_ep.num_streams) {
		dwc_debug0(pcd->usb3_dev, "Setting stream-capable bit\n");
		depcfg1 |= DWC_EPCFG1_STRM_CAP_BIT;
	}
#endif
	/* Save the DEPCFG parameters for later */
	if (ep->dwc_ep.is_in) {
		ep->dwc_ep.param0in = depcfg0 & ~DWC_EPCFG0_CFG_ACTION_BITS;
		ep->dwc_ep.param1in = depcfg1;
	} else {
		ep->dwc_ep.param0out = depcfg0 & ~DWC_EPCFG0_CFG_ACTION_BITS;
		ep->dwc_ep.param1out = depcfg1;
	}

	dwc_usb3_dep_cfg(pcd, ep_reg, depcfg0, depcfg1, depcfg2);

	/*
	 * Issue "DEPSTRMCFG" command to EP
	 */

	/* If this EP hasn't been enabled yet in this configuration */
	if (!ep->dwc_ep.ena_once) {
		ep->dwc_ep.ena_once = 1;

		/* One stream */
		dwc_debug0(pcd->usb3_dev, "Setting 1 stream resource\n");
		dwc_usb3_dep_xfercfg(pcd, ep_reg, 1);
	}

#ifdef DWC_STAR_9000463548_WORKAROUND
skip:
#endif
	/* Enable EP in DALEPENA reg */
	dwc_usb3_enable_ep(pcd, ep);

	ep->dwc_ep.active = 1;
	ep->dwc_ep.stall_clear_flag = 0;
}

/**
 * This function deactivates an EP.
 *
 * @param pcd Programming view of DWC_usb3 peripheral controller.
 * @param ep  The EP to deactivate.
 */
static void ep_deactivate(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	unsigned char tri;

	pcd_debug( "%s() EP%d-%s\n", __func__, ep->dwc_ep.num,
		   (ep->dwc_ep.is_in ? "IN" : "OUT"));
	/*
	 * Get the appropriate EP registers
	 */
	if (ep->dwc_ep.is_in) {
		ep_reg = ep->dwc_ep.in_ep_reg;
		tri = ep->dwc_ep.tri_in;
		ep->dwc_ep.tri_in = 0;
	} else {
		ep_reg = ep->dwc_ep.out_ep_reg;
		tri = ep->dwc_ep.tri_out;
		ep->dwc_ep.tri_out = 0;
	}

	pcd_debug( "end: DWC EP=%p tri=%d\n", ep, tri);

	if (tri) {
		/* Execute clear stall command */
		dwc_usb3_dep_cstall(pcd, ep_reg);

#ifdef DWC_STAR_9000463548_WORKAROUND
		/* For the workaround, we wait until the EP is re-enabled
		 * before waiting for the end transfer to complete
		 */
		dwc_usb3_dep_endxfer_nowait(pcd, ep_reg, tri, 1);
		if (ep->dwc_ep.is_in)
			ep->dwc_ep.tri_in = tri;
		else
			ep->dwc_ep.tri_out = tri;
#else
		/* Execute end transfer command */
		ep->dwc_ep.condition = 0;
		dwc_usb3_dep_endxfer(pcd, ep_reg, tri, 1,
				     &ep->dwc_ep.condition);
#endif
	}

	ep->dwc_ep.xfer_started = 0;

	/* Disable EP in DALEPENA reg */
	dwc_usb3_disable_ep(pcd, ep);

	ep->dwc_ep.active = 0;
}

/**
 * This function enables EPO-OUT to receive SETUP packets.
 *
 * @param pcd Programming view of the PCD.
 */
void dwc_usb3_ep0_out_start(dwc_usb3_pcd_t *pcd)
{
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	unsigned char tri;

	/* Get the SETUP packet DMA Descriptor (TRB) */
	desc = pcd->ep0_setup_desc;
	desc_dma = pcd->ep0_setup_desc_dma;

	/* DMA Descriptor setup */
	dwc_usb3_fill_desc(desc, pcd->ep0_setup_pkt_dma,
			   pcd->ep0->dwc_ep.maxpacket,
			   0, DWC_DSCCTL_TRBCTL_SETUP, DWC_DSCCTL_IOC_BIT |
			   DWC_DSCCTL_ISP_BIT | DWC_DSCCTL_LST_BIT, 1);
	pcd_debug(
		   "%s() desc=0x%08lx xfercnt=%u bptr=0x%08x:%08x\n",
		   __func__, (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
		   desc->bpth, desc->bptl);
#ifdef VERBOSE
	dwc_debug4(pcd->usb3_dev, "0x%08x 0x%08x 0x%08x 0x%08x\n",
		   *((unsigned *)desc), *((unsigned *)desc + 1),
		   *((unsigned *)desc + 2), *((unsigned *)desc + 3));
#endif
	ep_reg = &pcd->out_ep_regs[0];

	/* Issue "DEPSTRTXFER" command to EP0-OUT */
	tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
	pcd->ep0->dwc_ep.tri_out = tri;
}

/**
 * This function does the setup for a data transfer for EP0 and starts
 * the transfer.
 *
 * @param pcd Programming view of DWC_usb3 peripheral controller.
 * @param req The request to start.
 */
void dwc_usb3_ep0_start_transfer(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_req_t *req)
{
	dwc_usb3_pcd_ep_t *ep0 = pcd->ep0;
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	unsigned int desc_type, len;
	unsigned char tri;

	pcd_debug(
		"%s(): ep%d-%s req=%p xfer_len=%d xfer_cnt=%d xfer_buf=0x%p\n",
		__func__, ep0->dwc_ep.num, (ep0->dwc_ep.is_in ? "IN" : "OUT"),
		req, req->dwc_req.length, req->dwc_req.actual, req->dwc_req.buf[0]);

	/* Get the DMA Descriptor (TRB) for this request */
	dwc_usb3_os_get_trb(pcd, ep0, req);
	desc = req->dwc_req.trb;
	desc_dma = req->dwc_req.trbdma;

	if (ep0->dwc_ep.is_in) {
		/*
		 * Start DMA on EP0-IN
		 */
		ep_reg = ep0->dwc_ep.in_ep_reg;

		/* DMA Descriptor (TRB) setup */
		len = req->dwc_req.length;

		pcd_debug( "IN EP0STATE=%d\n", pcd->ep0state);

		if (pcd->ep0state == EP0_IN_STATUS_PHASE) {
			if (ep0->dwc_ep.three_stage)
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_3;
			else
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_2;
		} else {
			desc_type = DWC_DSCCTL_TRBCTL_CTLDATA_1ST;
		}

		dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[0],
				   len, 0, desc_type,
				   DWC_DSCCTL_IOC_BIT | DWC_DSCCTL_ISP_BIT |
				   DWC_DSCCTL_LST_BIT, 1);
		//dwc_debug4(pcd->usb3_dev,
		//	   "IN desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
		//	   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
		//	   desc->bpth, desc->bptl);
//#ifdef VERBOSE
		//dwc_debug4(pcd->usb3_dev, "0x%08x 0x%08x 0x%08x 0x%08x\n",
		//	   *((unsigned *)desc), *((unsigned *)desc + 1),
		//	   *((unsigned *)desc + 2), *((unsigned *)desc + 3));
//#endif
		/* Issue "DEPSTRTXFER" command to EP0-IN */
		tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
		ep0->dwc_ep.tri_in = tri;
	} else {
		/*
		 * Start DMA on EP0-OUT
		 */
		ep_reg = ep0->dwc_ep.out_ep_reg;

		/* DMA Descriptor (TRB) setup */
		len = (req->dwc_req.length + ep0->dwc_ep.maxpacket - 1) &
			~(ep0->dwc_ep.maxpacket - 1);

		pcd_debug( "OUT EP0STATE=%d\n", pcd->ep0state);

		if (pcd->ep0state == EP0_OUT_STATUS_PHASE) {
			if (ep0->dwc_ep.three_stage)
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_3;
			else
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_2;
		} else {
			desc_type = DWC_DSCCTL_TRBCTL_CTLDATA_1ST;
		}

		dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[0],
				   len, 0, desc_type,
				   DWC_DSCCTL_IOC_BIT | DWC_DSCCTL_ISP_BIT |
				   DWC_DSCCTL_LST_BIT, 1);
		//dwc_debug4(pcd->usb3_dev,
		//	   "OUT desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
		//	   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
		//	   desc->bpth, desc->bptl);
//#ifdef VERBOSE
		//dwc_debug4(pcd->usb3_dev, "0x%08x 0x%08x 0x%08x 0x%08x\n",
		//	   *((unsigned *)desc), *((unsigned *)desc + 1),
		//	   *((unsigned *)desc + 2), *((unsigned *)desc + 3));
//#endif
		/* Issue "DEPSTRTXFER" command to EP0-OUT */
		tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
		ep0->dwc_ep.tri_out = tri;
	}
}

/**
 * This function continues control IN transfers started by ep0_start_transfer,
 * when the transfer does not fit in a single request.
 *
 * @param pcd Programming view of DWC_usb3 peripheral controller.
 * @param req The request to continue.
 */
static void ep0_continue_transfer(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_req_t *req)
{
	dwc_usb3_pcd_ep_t *ep0 = pcd->ep0;
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	unsigned char tri;

	/* Currently the EP0 buffer size in the gadget is at least 256 bytes,
	 * and all control transfers are smaller than that, so this function is
	 * never called to continue a transfer. However it can be called to
	 * send a 0-length packet after the end of a transfer, so the code here
	 * only supports that case.
	 */

	pcd_debug( "%s()\n", __func__);

	if (ep0->dwc_ep.is_in) {
		desc = pcd->ep0_in_desc;
		desc_dma = pcd->ep0_in_desc_dma;
		ep_reg = ep0->dwc_ep.in_ep_reg;

		/* DMA Descriptor Setup */
		dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[0],
				   0, 0, DWC_DSCCTL_TRBCTL_NORMAL,
				   DWC_DSCCTL_IOC_BIT | DWC_DSCCTL_ISP_BIT |
				   DWC_DSCCTL_LST_BIT, 1);

		tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
		ep0->dwc_ep.tri_in = tri;
	}
}

/**
 * This function does the setup for a data transfer for an EP and starts
 * the transfer.
 *
 * @param pcd    Programming view of DWC_usb3 peripheral controller.
 * @param ep     The EP to start the transfer on.
 * @param req    The request to start.
 * @param event  If non-zero, this is the first transfer for an Isoc EP, so we
 *               must calculate the starting uFrame and do a startxfer instead
 *               of an updatexfer.
 */
void dwc_usb3_ep_start_transfer(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
				dwc_usb3_pcd_req_t *req, unsigned int event)
{
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	unsigned int len, tlen, pkts, ctrl;
	unsigned int intvl, mask, current_uf, target_uf = 0;
	unsigned char tri;
	int i;
#if defined(DEBUG) || defined(ISOC_DEBUG)
	unsigned int dcfg, dsts;
#endif

	dprintf(3, 
		    "\n%s(): ep%d-%s (%d phys) %p max_pkt=%d req=%p"
		    " xfer_len=%d xfer_cnt=%d xfer_buf=%p\n",
		    __func__, ep->dwc_ep.num, (ep->dwc_ep.is_in ? "IN" : "OUT"),
		    ep->dwc_ep.phys, ep, ep->dwc_ep.maxpacket, req,
		    req->dwc_req.length, req->dwc_req.actual,
		    req->dwc_req.buf[0]);


	dprintf(3, 
		    "%s(): ep%d-%s"
		    " xfer_len=%d xfer_cnt=%d\n",
		    __func__, ep->dwc_ep.num, (ep->dwc_ep.is_in ? "IN" : "OUT"),
		    req->dwc_req.length, req->dwc_req.actual);

	ep->dwc_ep.hiber_desc_idx = 0;

	/* If first transfer for Isoc */
	if (event) {
		/* Get the uFrame of the host request */
		current_uf = (event >> DWC_DEPEVT_ISOC_UFRAME_NUM_SHIFT) &
			     (DWC_DEPEVT_ISOC_UFRAME_NUM_BITS >>
					DWC_DEPEVT_ISOC_UFRAME_NUM_SHIFT);

		/* Get the EP's interval */
		intvl = 1 << ep->dwc_ep.intvl;

		/* Get the EP's interval mask */
		mask = ~(intvl - 1);

		/* Calculate a start time which is 2 or 4 intervals in the
		 * future
		 */
		if (intvl < 16)
			target_uf = (current_uf & mask) + (intvl << 2);
		else
			target_uf = (current_uf & mask) + (intvl << 1);

#if 0 //defined(DEBUG) || defined(ISOC_DEBUG)
		dcfg = dwc_rd32(pcd->usb3_dev, &pcd->dev_global_regs->dcfg);
		dsts = dwc_rd32(pcd->usb3_dev, &pcd->dev_global_regs->dsts);
		dwc_debug6(pcd->usb3_dev,
			   "dcfg:0x%1x dsts:0x%1x uf:0x%1x"
			   " intvl:0x%1x cur_uf:0x%1x tgt_uf:0x%1x\n",
			   dcfg, dsts, (dsts >> 3) & 0x3fff, intvl, current_uf,
			   target_uf);
		dwc_isocdbg4(pcd->usb3_dev,
			     "now:%1x bIvl:%1x ivl:%1x(u)f tgt:%1x\n",
			     (dsts >> 3) & 0x3fff, ep->dwc_ep.intvl + 1, intvl,
			     target_uf);
#endif
		/* Make sure 'target_uf' is non-zero so the code below knows
		 * that this is the first Isoc xfer. It will decrement the
		 * value by 1 before using it
		 */
		target_uf++;
	}

	/* Get the TRB for this request */
	dwc_usb3_os_get_trb(pcd, ep, req);

	ep->dwc_ep.send_zlp = 0;
	req->dwc_req.flags |= DWC_PCD_REQ_STARTED;
	desc = req->dwc_req.trb;
	desc_dma = req->dwc_req.trbdma;
	pkts = 0;

	if (ep->dwc_ep.is_in) {
		/* For IN, TRB length is just xfer length */
		len = req->dwc_req.length;

		if (ep->dwc_ep.type == UE_ISOCHRONOUS &&
						pcd->speed == USB_SPEED_HIGH) {
			pkts = (len + ep->dwc_ep.maxpacket - 1)
				/ ep->dwc_ep.maxpacket;
			if (pkts)
				pkts--;
		}
	} else {
		/* For OUT, TRB length must be multiple of maxpacket */
		if ((ep->dwc_ep.type == UE_ISOCHRONOUS ||
				ep->dwc_ep.type == UE_INTERRUPT) &&
						ep->dwc_ep.maxpacket != 1024)
			/* Might not be power of 2, so use (expensive?)
			 * divide/multiply
			 */
			len = ((req->dwc_req.length + ep->dwc_ep.maxpacket - 1)
			       / ep->dwc_ep.maxpacket) * ep->dwc_ep.maxpacket;
		else
			/* Must be power of 2, use cheap AND */
			len = (req->dwc_req.length + ep->dwc_ep.maxpacket - 1)
			      & ~(ep->dwc_ep.maxpacket - 1);

		req->dwc_req.length = len;
	}

	/* DMA Descriptor Setup */
	for (i = 0; i < req->dwc_req.numbuf; i++, desc++) {
		if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
			if (i != req->dwc_req.numbuf - 1) {
				tlen = req->dwc_req.buflen[i];
				len -= tlen;
			} else {
				tlen = len;
			}

			if (i == 0)
				tlen |= pkts << DWC_DSCSTS_PCM1_SHIFT;

			dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[i],
					   tlen, 0, 0, 0, i != 0);
		} else {
			ctrl = DWC_DSCCTL_ISP_BIT;

			if (i != req->dwc_req.numbuf - 1) {
				tlen = req->dwc_req.buflen[i];
				len -= tlen;
			} else {
				ctrl |= DWC_DSCCTL_IOC_BIT | DWC_DSCCTL_LST_BIT;
				tlen = len;
			}

			dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[i],
					   tlen, req->dwc_req.stream,
					   DWC_DSCCTL_TRBCTL_NORMAL, ctrl,
					   i != 0);
		}
	}

	/* Must do this last! */
	desc = req->dwc_req.trb;
	dwc_usb3_enable_desc(desc);

	if (ep->dwc_ep.is_in) {
		/*
		 * Start DMA on EPn-IN
		 */
		ep_reg = ep->dwc_ep.in_ep_reg;
		pcd_debug("IN desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
			   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
			   desc->bpth, desc->bptl);
#ifdef VERBOSE
		pcd_debug( "%08x %08x %08x %08x (%08x)\n",
			   *((unsigned *)desc), *((unsigned *)desc + 1),
			   *((unsigned *)desc + 2), *((unsigned *)desc + 3),
			   (unsigned)desc_dma);
#endif
		/* If Isoc */
		if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
			if (ep->dwc_ep.xfer_started) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							ep->dwc_ep.tri_in);
			} else if (target_uf) {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							     desc_dma,
							     target_uf - 1);
				ep->dwc_ep.tri_in = tri;
				ep->dwc_ep.xfer_started = 1;
			} else {
				//dwc_print0(pcd->usb3_dev,
				//	   "Not starting isoc IN!\n");
			}
		} else {
			if (ep->dwc_ep.xfer_started) {
				/* Issue "DEPUPDTXFER" command to EP */
				if (ep->dwc_ep.num == 2) {
					tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
								desc_dma,
								req->dwc_req.stream);
				}

				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							ep->dwc_ep.tri_in);
			} else {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							desc_dma,
							req->dwc_req.stream);
				ep->dwc_ep.tri_in = tri;
				ep->dwc_ep.xfer_started = 1;
			}
		}
	} else {
		/*
		 * Start DMA on EPn-OUT
		 */
		ep_reg = ep->dwc_ep.out_ep_reg;
		pcd_debug( "OUT desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
			   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
			   desc->bpth, desc->bptl);
#ifdef VERBOSE
		pcd_debug( "%08x %08x %08x %08x (%08x)\n",
			   *((unsigned *)desc), *((unsigned *)desc + 1),
			   *((unsigned *)desc + 2), *((unsigned *)desc + 3),
			   (unsigned)desc_dma);
#endif
		/* If Isoc */
		if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
			if (ep->dwc_ep.xfer_started) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							ep->dwc_ep.tri_out);
			} else if (target_uf) {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							     desc_dma,
							     target_uf - 1);
				ep->dwc_ep.tri_out = tri;
				ep->dwc_ep.xfer_started = 1;
			} else {
				//dwc_print0(pcd->usb3_dev,
				//	   "Not starting isoc OUT!\n");
			}
		} else {
			if (ep->dwc_ep.xfer_started) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							ep->dwc_ep.tri_in);
			} else {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							desc_dma,
							req->dwc_req.stream);
				ep->dwc_ep.tri_out = tri;
				ep->dwc_ep.xfer_started = 1;
			}
		}
	}
}

/**
 * Stop any active xfers on the non-EP0 endpoints.
 */
void dwc_usb3_stop_all_xfers(dwc_usb3_pcd_t *pcd)
{
	int i;
	dwc_usb3_pcd_ep_t *ep;
	dwc_usb3_dev_ep_regs_t   *ep_reg;

	pcd_debug( "%s()\n", __func__);

	/* Stop any active xfers on the non-EP0 IN endpoints */
	for (i = pcd->num_in_eps; i > 0; i--) {
		ep = pcd->in_ep[i - 1];
		dwc_print3(pcd->usb3_dev, "DWC IN EP%d=%p tri-in=%d\n",
			   i, ep, ep->dwc_ep.tri_in);
		if (ep->dwc_ep.active && ep->dwc_ep.tri_in) {
			ep_reg = ep->dwc_ep.in_ep_reg;
			ep->dwc_ep.condition = 0;
			dwc_usb3_dep_endxfer(pcd, ep_reg, ep->dwc_ep.tri_in, 1,
					     &ep->dwc_ep.condition);
			ep->dwc_ep.tri_in = 0;
		}

		//dwc_usb3_os_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
		ep->dwc_ep.desc_idx = 0;
		ep->dwc_ep.hiber_desc_idx = 0;
	}

	/* Stop any active xfers on the non-EP0 OUT endpoints */
	for (i = pcd->num_out_eps; i > 0; i--) {
		ep = pcd->out_ep[i - 1];
		dwc_print3(pcd->usb3_dev, "DWC OUT EP%d=%p tri-out=%d\n",
			   i, ep, ep->dwc_ep.tri_out);
		if (ep->dwc_ep.active && ep->dwc_ep.tri_out) {
			ep_reg = ep->dwc_ep.out_ep_reg;
			ep->dwc_ep.condition = 0;
			dwc_usb3_dep_endxfer(pcd, ep_reg, ep->dwc_ep.tri_out, 1,
					     &ep->dwc_ep.condition);
			ep->dwc_ep.tri_out = 0;
		}

		//dwc_usb3_os_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
		ep->dwc_ep.desc_idx = 0;
		ep->dwc_ep.hiber_desc_idx = 0;
	}
}

/**
 * This function completes the ep0 control transfer.
 */
static int ep0_complete_request(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_req_t *req,
				dwc_usb3_dma_desc_t *desc, int status)
{
	dwc_usb3_pcd_ep_t *ep = pcd->ep0;
	int is_last = 0;

	dwc_debug4(pcd->usb3_dev, "%s(%p,%p,%d)\n",
		   __func__, req, desc, status);

	if (pcd->ep0_status_pending && !req) {
		if (ep->dwc_ep.is_in) {
#ifdef DEBUG_EP0
			dwc_debug0(pcd->usb3_dev,
				   "Do setup OUT status phase\n");
#endif
			pcd->ep0->dwc_ep.is_in = 0;
			pcd->ep0state = EP0_OUT_WAIT_NRDY;
		} else {
#ifdef DEBUG_EP0
			dwc_debug0(pcd->usb3_dev, "Do setup IN status phase\n");
#endif
			pcd->ep0->dwc_ep.is_in = 1;
			pcd->ep0state = EP0_IN_WAIT_NRDY;
		}

		pcd->ep0_status_pending = 0;
		return 1;
	}

	if (!req)
		return 0;

	pcd_debug( "req=%p\n", req);

	if (pcd->ep0state == EP0_OUT_STATUS_PHASE ||
	    pcd->ep0state == EP0_IN_STATUS_PHASE) {
		is_last = 1;

	} else if (ep->dwc_ep.is_in) {
#ifdef DEBUG_EP0
		dwc_debug4(pcd->usb3_dev,
			   "IN len=%d actual=%d xfrcnt=%d trbrsp=0x%02x\n",
			   req->dwc_req.length, req->dwc_req.actual,
			   dwc_usb3_get_xfercnt(desc),
			   dwc_usb3_get_xfersts(desc));
#endif
		if (dwc_usb3_get_xfercnt(desc) == 0) {
			/* Is a Zero Len Packet needed? */
			if (req->dwc_req.flags & DWC_PCD_REQ_ZERO) {
#ifdef DEBUG_EP0
				dwc_debug0(pcd->usb3_dev, "Setup Rx ZLP\n");
#endif
				req->dwc_req.flags &= ~DWC_PCD_REQ_ZERO;
			}

			pcd->ep0->dwc_ep.is_in = 0;
			pcd->ep0state = EP0_OUT_WAIT_NRDY;
		}
	} else {
#ifdef DEBUG_EP0
		dwc_debug4(pcd->usb3_dev,
			   "OUT len=%d actual=%d xfrcnt=%d trbrsp=0x%02x\n",
			   req->dwc_req.length, req->dwc_req.actual,
			   dwc_usb3_get_xfercnt(desc),
			   dwc_usb3_get_xfersts(desc));
#endif
		/* Is a Zero Len Packet needed? */
		if (req->dwc_req.flags & DWC_PCD_REQ_ZERO) {
#ifdef DEBUG_EP0
			dwc_debug0(pcd->usb3_dev, "Setup Tx ZLP\n");
#endif
			req->dwc_req.flags &= ~DWC_PCD_REQ_ZERO;
		}

		pcd->ep0->dwc_ep.is_in = 1;
		pcd->ep0state = EP0_IN_WAIT_NRDY;
	}

	/* Complete the request */
	if (is_last) {
		dwc_debug2(pcd->usb3_dev, "is_last len=%d actual=%d\n",
			   req->dwc_req.length, req->dwc_req.actual);
		dwc_usb3_request_done(pcd, ep, req, status);
		return 1;
	}

	return 0;
}

/**
 * This function completes the request for the EP. If there are additional
 * requests for the EP in the queue they will be started.
 */
int dwc_usb3_ep_complete_request(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
				 dwc_usb3_pcd_req_t *req, unsigned int event)
{
	dwc_usb3_device_t *dev = pcd->usb3_dev;
	int is_last = 0, ret = 0;
	int now_uf, evt_uf, status, diff, intvl, tri, i;
	dwc_usb3_dma_desc_t *desc;
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	unsigned int byte_count;
#if defined(DEBUG) || defined(ISOC_DEBUG)
	unsigned int bmudbg;
	static unsigned int old0, old1, old2, old3, old4;
#endif

	dwc_debug1(dev, "%s()\n", __func__);

	ep->dwc_ep.send_zlp = 0;
	desc = req->dwc_req.trb;
	dwc_debug2(dev, "req=%p desc=%p\n", req, desc);

	if (!desc) {
		pcd_debug( "### %s, EP%d-%s request TRB is NULL! ###\n",
			     __func__, ep->dwc_ep.num, ep->dwc_ep.is_in ?
			     "IN" : "OUT");
		return ret;
	}

	if (!(req->dwc_req.flags & DWC_PCD_REQ_STARTED)) {
		pcd_debug(  "### %s, EP%d-%s request not started! ###\n",
			     __func__, ep->dwc_ep.num, ep->dwc_ep.is_in ?
			     "IN" : "OUT");
		return ret;
	}

	if (dwc_usb3_is_hwo(desc)) {
		pcd_debug( "### %s, EP%d-%s HWO bit set! ###\n",
			     __func__, ep->dwc_ep.num, ep->dwc_ep.is_in ?
			     "IN" : "OUT");
		return ret;
	}

	if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
		now_uf = dwc_usb3_get_frame(pcd);
		evt_uf = dwc_usb3_get_eventsofn(event);
		pcd_debug( 
			"ep:%1x evt:%08x frm:%04x now:%04x trb:%1lx len:%04x\n",
			ep->dwc_ep.num, event, evt_uf, now_uf,
			((unsigned long)req->dwc_req.trbdma -
			 (unsigned long)ep->dwc_ep.dma_desc_dma) /
			(req->dwc_req.numbuf * 16), dwc_usb3_get_xfercnt(desc));
		/*dwc_isocdbg4(dev, "this trb: %08x %08x %08x %08x\n",
			*((unsigned *)desc), *((unsigned *)desc + 1),
			*((unsigned *)desc + 2), *((unsigned *)desc + 3));
		dwc_isocdbg4(dev, "next trb: %08x %08x %08x %08x\n",
			*((unsigned *)desc + 4), *((unsigned *)desc + 5),
			*((unsigned *)desc + 6), *((unsigned *)desc + 7));*/

		status = dwc_usb3_get_xfersts(desc);
		if (status & DWC_TRBRSP_MISSED_ISOC_IN) {
#if defined(DEBUG) || defined(ISOC_DEBUG)
			/* Undocumented BMU debug register */
			bmudbg = dwc_rd32(dev, dev->base + 0xc16c);
			dwc_isocdbg1(dev,
				     "(%01x) Missed Isoc! (cmpl as 0-len)\n",
				     status);
			/*dwc_isocdbg5(dev, "%08x %08x %08x %08x (%08x)\n",
			       *((unsigned *)desc), *((unsigned *)desc + 1),
			       *((unsigned *)desc + 2), *((unsigned *)desc + 3),
			       bmudbg);
			dwc_isocdbg5(dev, "prev: %08x %08x %08x %08x (%08x)\n",
				     old0, old1, old2, old3, old4);*/
#endif
			/* Only valid to check uFrame on TRBs with IOC set */
			if (!dwc_usb3_is_ioc(desc))
				goto no_restart;

			/* Check uFrame from event to see if we are too far off
			 * and need to restart the EP
			 */
			evt_uf &= 0x3fff;
			diff = now_uf - evt_uf;
			if (diff < 0)
				diff += 0x4000;
			intvl = 1 << ep->dwc_ep.intvl;
			dwc_isocdbg2(dev, "diff %1x intvl %1x\n", diff, intvl);

#if 0	// dump debug regs
			{
				unsigned int wr_data, rd_data, rd_data2;

				for (i = 0; i < 11; i++) {
					wr_data = i << 4;
					dwc_wr32(dev, dev->base + 0xc170, wr_data);
					rd_data = dwc_rd32(dev, dev->base + 0xc174);
					dwc_isocdbg1(dev, "lsp: %08x\n", rd_data);
				}

				for (i = 0; i < 8; i++) {
					wr_data = i;
					dwc_wr32(dev, dev->base + 0xc170, wr_data);
					rd_data = dwc_rd32(dev, dev->base + 0xc178);
					rd_data2 = dwc_rd32(dev, dev->base + 0xc17c);
					dwc_isocdbg2(dev, " ep: %08x  %08x\n",
						     rd_data, rd_data2);
				}

				rd_data = dwc_rd32(dev, dev->base + 0xc16c);
				dwc_isocdbg1(dev, "bmu: %08x\n", rd_data);
			}
#endif
			if (diff < intvl * 2)
				goto no_restart;

			/* Something has gone wrong, shut down the EP and then
			 * restart it
			 */
			pcd_debug(  "Restart!\n");
			if (ep->dwc_ep.is_in) {
				ep_reg = ep->dwc_ep.in_ep_reg;
				tri = ep->dwc_ep.tri_in;
				ep->dwc_ep.tri_in = 0;
				pcd_debug(  "IN tri=%1x\n", tri);
			} else {
				ep_reg = ep->dwc_ep.out_ep_reg;
				tri = ep->dwc_ep.tri_out;
				ep->dwc_ep.tri_out = 0;
				pcd_debug(  "OUT tri=%1x\n", tri);
			}

			if (ep->dwc_ep.active && tri) {
				ep->dwc_ep.condition = 0;
				dwc_usb3_dep_endxfer(pcd, ep_reg, tri, 1,
						     &ep->dwc_ep.condition);
			}

			ep->dwc_ep.xfer_started = 0;

			/* Tell caller to mark all queued requests as
			 * not started
			 */
			ret = -1;
no_restart:
			req->dwc_req.actual = 0;
			is_last = 1;
			goto done;

#if defined(DEBUG) || defined(ISOC_DEBUG)
		} else {
			old0 = *((unsigned *)desc);
			old1 = *((unsigned *)desc + 1);
			old2 = *((unsigned *)desc + 2);
			old3 = *((unsigned *)desc + 3);

			/* Undocumented BMU debug register */
			old4 = dwc_rd32(dev, dev->base + 0xc16c);
#endif
		}
	}

	if (ep->dwc_ep.is_in) {	/* IN endpoint */
		for (i = 0; i < req->dwc_req.numbuf; i++, desc++) {
			if (dwc_usb3_get_xfercnt(desc) == 0) {
				req->dwc_req.actual += req->dwc_req.length;
				if (i == req->dwc_req.numbuf - 1)
					is_last = 1;
			} else {
				pcd_debug(  "Incomplete transfer!\n");
			}
		}

		if (i)
			desc--;
		pcd_debug( "IN len=%d cnt=%d rem=%d\n",
			   req->dwc_req.length, req->dwc_req.actual,
			   dwc_usb3_get_xfercnt(desc));

	} else {		/* OUT endpoint */
		for (i = 0; i < req->dwc_req.numbuf; i++, desc++) {
			byte_count = req->dwc_req.length -
						dwc_usb3_get_xfercnt(desc);
			req->dwc_req.actual += byte_count;
		}

		if (i)
			desc--;
		pcd_debug( "OUT len=%d cnt=%d rem=%d\n",
			   req->dwc_req.length, req->dwc_req.actual,
			   dwc_usb3_get_xfercnt(desc));
		is_last = 1;

		if (dev->core_params->u1u2ctl &&
		    ep->dwc_ep.type == UE_BULK &&
		    req->dwc_req.actual == 31 &&
		    req->dwc_req.buf[0][0] == 0x55 &&
		    req->dwc_req.buf[0][1] == 0x53 &&
		    req->dwc_req.buf[0][2] == 0x42 &&
		    req->dwc_req.buf[0][3] == 0x43) {
			unsigned int dctl;

			/* If BOT CBW, disable U1/U2 entry */
			dctl = dwc_rd32(dev, &pcd->dev_global_regs->dctl);
			dctl &= ~(DWC_DCTL_INIT_U1_EN_BIT |
				  DWC_DCTL_INIT_U2_EN_BIT);
			dwc_wr32(dev, &pcd->dev_global_regs->dctl, dctl);
		}
	}

done:
	if ((event & DWC_DEPEVT_INTTYPE_BITS) ==
	    (DWC_DEPEVT_XFER_CMPL << DWC_DEPEVT_INTTYPE_SHIFT)) {
		if (ep->dwc_ep.is_in)
			ep->dwc_ep.tri_in = 0;
		else
			ep->dwc_ep.tri_out = 0;
	}

	/* Complete the request */
	if (is_last) {
//		dwc_usb3_request_done(pcd, ep, req, 0);
		//dwc_info2(dev, "ep_complete_request - start req %d-%s\n",
		//	  ep->dwc_ep.num, ep->dwc_ep.is_in ? "IN" : "OUT");
#if 0		/* 012.10.28 */
		if (ep->dwc_ep.type != UE_ISOCHRONOUS ||
						ep->dwc_ep.xfer_started)
			/* If there is a request in the queue start it. */
			dwc_usb3_os_start_next_request(pcd, ep);
#endif /* 0 */

#ifdef DWC_ISOC_INTR_MODERATION
		/* Handle Isoc interrupt moderation */
		if (ep->dwc_ep.type == UE_ISOCHRONOUS &&
		    ep->dwc_ep.xfer_started && !dwc_usb3_is_ioc(desc))
			/* Tell caller we want to process next TRB */
			ret = 1;
#endif
	} else {
		dwc_print2(dev, "### EP%d-%s is_last not set! ###\n",
			   ep->dwc_ep.num, ep->dwc_ep.is_in ? "IN" : "OUT");
	}

	return ret;
}

/**
 * Set the EP STALL.
 *
 * @param pcd Programming view of DWC_usb3 peripheral controller.
 * @param ep  The EP to set the stall on.
 */
void dwc_usb3_ep_set_stall(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t   *ep_reg;

	dwc_info2(pcd->usb3_dev, "%s(%p)\n", __func__, ep);
	dwc_info2(pcd->usb3_dev, "ep_num=%d is_in=%d\n",
		  ep->dwc_ep.num, ep->dwc_ep.is_in);

	if (ep->dwc_ep.is_in)
		ep_reg = ep->dwc_ep.in_ep_reg;
	else
		ep_reg = ep->dwc_ep.out_ep_reg;

	dwc_usb3_dep_sstall(pcd, ep_reg);
}

/**
 * Clear the EP STALL.
 *
 * @param pcd Programming view of DWC_usb3 peripheral controller.
 * @param ep  The EP to clear the stall on.
 */
void dwc_usb3_ep_clear_stall(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t   *ep_reg;

	pcd_debug( "%s()\n", __func__);
	dwc_debug2(pcd->usb3_dev, "ep_num=%d is_in=%d\n",
		   ep->dwc_ep.num, ep->dwc_ep.is_in);

	if (ep->dwc_ep.is_in)
		ep_reg = ep->dwc_ep.in_ep_reg;
	else
		ep_reg = ep->dwc_ep.out_ep_reg;

	dwc_usb3_dep_cstall(pcd, ep_reg);
}

/**
 * This function returns a pointer to Out EP struct with number ep_num.
 */
dwc_usb3_pcd_ep_t *dwc_usb3_get_out_ep(dwc_usb3_pcd_t *pcd, unsigned int ep_num)
{
	//dwc_debug2(pcd->usb3_dev, "%s(%d)\n", __func__, ep_num);

	if (ep_num == 0)
		return pcd->ep0;
	else
		return pcd->out_ep[ep_num - 1];
}

/**
 * This function returns a pointer to In EP struct with number ep_num.
 */
dwc_usb3_pcd_ep_t *dwc_usb3_get_in_ep(dwc_usb3_pcd_t *pcd, unsigned int ep_num)
{
	//dwc_debug2(pcd->usb3_dev, "%s(%d)\n", __func__, ep_num);

	if (ep_num == 0)
		return pcd->ep0;
	else
		return pcd->in_ep[ep_num - 1];
}

/**
 * This function gets a pointer to an EP from the wIndex address value of the
 * control request.
 */
dwc_usb3_pcd_ep_t *dwc_usb3_get_ep_by_addr(dwc_usb3_pcd_t *pcd, unsigned short index)
{
	unsigned int ep_num = UE_GET_ADDR(index);

	//dwc_debug2(pcd->usb3_dev, "%s(%d)\n", __func__, index);

	if (UE_GET_DIR(index) == UE_DIR_IN)
		return dwc_usb3_get_in_ep(pcd, ep_num);
	else
		return dwc_usb3_get_out_ep(pcd, ep_num);
}

/**
 * This function starts the Zero-Length Packet for the IN status phase of a
 * control write transfer.
 */
static void setup_in_status_phase(dwc_usb3_pcd_t *pcd, void *buf,
				  dwc_dma_t dma)
{
	dwc_usb3_pcd_ep_t *ep0 = pcd->ep0;

	pcd_debug( "%s()\n", __func__);

	if (pcd->ep0state == EP0_STALL) {
		dwc_debug0(pcd->usb3_dev, "EP0 STALLED\n");
		return;
	}

	ep0->dwc_ep.is_in = 1;
	pcd->ep0state = EP0_IN_STATUS_PHASE;

	dwc_debug0(pcd->usb3_dev, "EP0 IN ZLP\n");

	pcd->ep0_req->dwc_req.buf[0] = buf;
	pcd->ep0_req->dwc_req.bufdma[0] = dma;
	pcd->ep0_req->dwc_req.length = 0;
	pcd->ep0_req->dwc_req.actual = 0;
	dwc_usb3_ep0_start_transfer(pcd, pcd->ep0_req);
}

/**
 * This function starts the Zero-Length Packet for the OUT status phase of a
 * control read transfer.
 */
static void setup_out_status_phase(dwc_usb3_pcd_t *pcd, void *buf,
				   dwc_dma_t dma)
{
	dwc_usb3_pcd_ep_t *ep0 = pcd->ep0;

	//pcd_debug( "%s()\n", __func__);

	if (pcd->ep0state == EP0_STALL) {
		dwc_debug0(pcd->usb3_dev, "EP0 STALLED\n");
		return;
	}

	ep0->dwc_ep.is_in = 0;
	pcd->ep0state = EP0_OUT_STATUS_PHASE;

	dwc_debug0(pcd->usb3_dev, "EP0 OUT ZLP\n");

	pcd->ep0_req->dwc_req.buf[0] = buf;
	pcd->ep0_req->dwc_req.bufdma[0] = dma;
	pcd->ep0_req->dwc_req.length = 0;
	pcd->ep0_req->dwc_req.actual = 0;
	dwc_usb3_ep0_start_transfer(pcd, pcd->ep0_req);
}

#ifdef DEBUG_EP0
/**
 * This function prints the ep0 state for debug purposes.
 */
void dwc_usb3_print_ep0_state(dwc_usb3_pcd_t *pcd)
{
#ifdef DEBUG
	char *str;

	switch (pcd->ep0state) {
	case EP0_IDLE:
		str = "EP0_IDLE";
		break;
	case EP0_IN_DATA_PHASE:
		str = "EP0_IN_DATA_PHASE";
		break;
	case EP0_OUT_DATA_PHASE:
		str = "EP0_OUT_DATA_PHASE";
		break;
	case EP0_IN_WAIT_GADGET:
		str = "EP0_IN_WAIT_GADGET";
		break;
	case EP0_OUT_WAIT_GADGET:
		str = "EP0_OUT_WAIT_GADGET";
		break;
	case EP0_IN_WAIT_NRDY:
		str = "EP0_IN_WAIT_NRDY";
		break;
	case EP0_OUT_WAIT_NRDY:
		str = "EP0_OUT_WAIT_NRDY";
		break;
	case EP0_IN_STATUS_PHASE:
		str = "EP0_IN_STATUS_PHASE";
		break;
	case EP0_OUT_STATUS_PHASE:
		str = "EP0_OUT_STATUS_PHASE";
		break;
	case EP0_STALL:
		str = "EP0_STALL";
		break;
	default:
		str = "EP0_INVALID";
	}

	dwc_debug2(pcd->usb3_dev, "%s(%d)\n", str, pcd->ep0state);
#endif
}
#endif

/**
 * This function handles EP0 Control transfers.
 *
 * The state of the control tranfers are tracked in <code>ep0state</code>.
 */
void dwc_usb3_handle_ep0(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_req_t *req,
			 unsigned int event)
{
	dwc_usb3_pcd_ep_t *ep0 = pcd->ep0;
	dwc_usb3_dma_desc_t *desc;
	unsigned int byte_count, len;
	int status;

#ifdef DEBUG_EP0
	pcd_debug( "%s()\n", __func__);
	dwc_usb3_print_ep0_state(pcd);
#endif
	dwc_debug0(pcd->usb3_dev, "HANDLE EP0\n");

	switch (pcd->ep0state) {
	case EP0_IN_DATA_PHASE:
		if (!req)
			req = pcd->ep0_req;
		desc = pcd->ep0_in_desc;
		pcd_debug( "req=%p\n", req);
#ifdef DEBUG_EP0
		pcd_debug(
			"DATA_IN EP%d-%s: type=%d mps=%d trb.status=0x%08x\n",
			ep0->dwc_ep.num, (ep0->dwc_ep.is_in ? "IN" : "OUT"),
			ep0->dwc_ep.type, ep0->dwc_ep.maxpacket, desc->status);
#endif
		if (dwc_usb3_is_hwo(desc)) {
			dwc_print3(pcd->usb3_dev,
				"### %s, EP%d-%s HWO bit set 1! ###\n",
				__func__, ep0->dwc_ep.num, ep0->dwc_ep.is_in ?
				"IN" : "OUT");
			goto out;
		}

		status = dwc_usb3_get_xfersts(desc);
		if (status & DWC_TRBRSP_SETUP_PEND) {
			/* Start of a new Control transfer */
			dwc_debug0(pcd->usb3_dev, "IN SETUP PENDING\n");
			desc->status = 0;
		}

		byte_count = req->dwc_req.length - dwc_usb3_get_xfercnt(desc);
		req->dwc_req.actual += byte_count;
		req->dwc_req.buf[0] += byte_count;
		req->dwc_req.bufdma[0] += byte_count;
		pcd_debug( "length=%d byte_count=%d actual=%d\n",
			req->dwc_req.length, byte_count, req->dwc_req.actual);

		if (req->dwc_req.actual < req->dwc_req.length) {
#ifdef DEBUG_EP0 // dump debug regs
			int i;
			unsigned int wr_data, rd_data, rd_data2;
			dwc_usb3_device_t *dev = pcd->usb3_dev;

			for (i = 0; i < 11; i++) {
				wr_data = i << 4;
				dwc_wr32(dev, dev->base + 0xc170, wr_data);
				rd_data = dwc_rd32(dev, dev->base + 0xc174);
				dwc_debug1(dev, "lsp: %08x\n", rd_data);
			}

			for (i = 0; i < 8; i++) {
				wr_data = i;
				dwc_wr32(dev, dev->base + 0xc170, wr_data);
				rd_data = dwc_rd32(dev, dev->base + 0xc178);
				rd_data2 = dwc_rd32(dev, dev->base + 0xc17c);
				dwc_debug2(dev, " ep: %08x  %08x\n",
					   rd_data, rd_data2);
			}

			rd_data = dwc_rd32(dev, dev->base + 0xc16c);
			dwc_debug1(dev, "bmu: %08x\n", rd_data);
#endif
			dwc_debug0(pcd->usb3_dev, "IN CONTINUE\n");
			//ep0_continue_transfer(pcd, req);
			//dwc_debug0(pcd->usb3_dev, "CONTINUE TRANSFER\n");
			dwc_debug0(pcd->usb3_dev, "Stall EP0\n");
			ep0->dwc_ep.is_in = 0;
			dwc_usb3_ep_set_stall(pcd, ep0);
			ep0->dwc_ep.stopped = 1;
			pcd->ep0state = EP0_IDLE;
			dwc_usb3_ep0_out_start(pcd);

		} else if (ep0->dwc_ep.send_zlp) {
			dwc_debug0(pcd->usb3_dev, "IN ZLP\n");
			ep0_continue_transfer(pcd, req);
			ep0->dwc_ep.send_zlp = 0;
			dwc_debug0(pcd->usb3_dev, "CONTINUE TRANSFER\n");

		} else {
			dwc_debug0(pcd->usb3_dev, "IN COMPLETE\n");
			/* This sets ep0state = EP0_IN/OUT_WAIT_NRDY */
			ep0_complete_request(pcd, req, desc, 0);
			dwc_debug0(pcd->usb3_dev, "COMPLETE TRANSFER\n");
		}

		break;

	case EP0_OUT_DATA_PHASE:
		if (!req)
			req = pcd->ep0_req;
		desc = pcd->ep0_out_desc;
		pcd_debug( "req=%p\n", req);
#ifdef DEBUG_EP0
		pcd_debug(
			"DATA_OUT EP%d-%s: type=%d mps=%d trb.status=0x%08x\n",
			ep0->dwc_ep.num, (ep0->dwc_ep.is_in ? "IN" : "OUT"),
			ep0->dwc_ep.type, ep0->dwc_ep.maxpacket, desc->status);
#endif
		if (dwc_usb3_is_hwo(desc)) {
			dwc_print3(pcd->usb3_dev,
				"### %s, EP%d-%s HWO bit set 2! ###\n",
				__func__, ep0->dwc_ep.num, ep0->dwc_ep.is_in ?
				"IN" : "OUT");
			goto out;
		}

		status = dwc_usb3_get_xfersts(desc);
		if (status & DWC_TRBRSP_SETUP_PEND) {
			/* Start of a new Control transfer */
			dwc_debug0(pcd->usb3_dev, "OUT SETUP PENDING\n");
		}

		len = (req->dwc_req.length + ep0->dwc_ep.maxpacket - 1) &
			~(ep0->dwc_ep.maxpacket - 1);
		byte_count = len - dwc_usb3_get_xfercnt(desc);
		req->dwc_req.actual += byte_count;
		req->dwc_req.buf[0] += byte_count;
		req->dwc_req.bufdma[0] += byte_count;
		pcd_debug( "length=%d byte_count=%d actual=%d\n",
			req->dwc_req.length, byte_count, req->dwc_req.actual);

		/*if (req->dwc_req.actual < req->dwc_req.length) {
			dwc_debug0(pcd->usb3_dev, "OUT CONTINUE\n");
			ep0_continue_transfer(pcd, req);
			dwc_debug0(pcd->usb3_dev, "CONTINUE TRANSFER\n");

		} else*/ if (ep0->dwc_ep.send_zlp) {
			dwc_debug0(pcd->usb3_dev, "OUT ZLP\n");
			ep0_continue_transfer(pcd, req);
			ep0->dwc_ep.send_zlp = 0;
			dwc_debug0(pcd->usb3_dev, "CONTINUE TRANSFER\n");

		} else {
			dwc_debug0(pcd->usb3_dev, "OUT COMPLETE\n");
			/* This sets ep0state = EP0_IN/OUT_WAIT_NRDY */
			ep0_complete_request(pcd, req, desc, 0);
			dwc_debug0(pcd->usb3_dev, "COMPLETE TRANSFER\n");
		}

		break;

	case EP0_IN_WAIT_GADGET:
		pcd->ep0state = EP0_IN_WAIT_NRDY;
		break;

	case EP0_OUT_WAIT_GADGET:
		pcd->ep0state = EP0_OUT_WAIT_NRDY;
		break;

	case EP0_IN_WAIT_NRDY:
	case EP0_OUT_WAIT_NRDY:
		if (ep0->dwc_ep.is_in)
			setup_in_status_phase(pcd, pcd->ep0_setup_pkt,
					      pcd->ep0_setup_pkt_dma);
		else
			setup_out_status_phase(pcd, pcd->ep0_setup_pkt,
					       pcd->ep0_setup_pkt_dma);
		break;

	case EP0_IN_STATUS_PHASE:
	case EP0_OUT_STATUS_PHASE:
		if (ep0->dwc_ep.is_in)
			desc = pcd->ep0_in_desc;
		else
			desc = pcd->ep0_out_desc;
#ifdef DEBUG_EP0
		dwc_debug2(pcd->usb3_dev, "STATUS EP%d-%s\n", ep0->dwc_ep.num,
			   (ep0->dwc_ep.is_in ? "IN" : "OUT"));
#endif
		ep0_complete_request(pcd, req, desc, 0);
		pcd->ep0state = EP0_IDLE;
		ep0->dwc_ep.stopped = 1;
		ep0->dwc_ep.is_in = 0;	/* OUT for next SETUP */

		/* Prepare for more SETUP Packets */
		dwc_usb3_ep0_out_start(pcd);
		break;

	case EP0_STALL:
		dwc_error0(pcd->usb3_dev, "EP0 STALLed, should not get here\n");
		break;

	case EP0_IDLE:
		dwc_error0(pcd->usb3_dev, "EP0 IDLE, should not get here\n");
		break;
	}
out:
#ifdef DEBUG_EP0
	dwc_usb3_print_ep0_state(pcd);
#endif
	return;
}

/* USB Endpoint Operations */
/*
 * The following sections briefly describe the behavior of the Gadget API
 * endpoint operations implemented in the DWC_usb3 driver software. Detailed
 * descriptions of the generic behavior of each of these functions can be
 * found in the Linux header file include/linux/usb_gadget.h.
 *
 * The Gadget API provides wrapper functions for each of the function
 * pointers defined in usb_ep_ops. The Gadget Driver calls the wrapper
 * function, which then calls the underlying PCD function. The following
 * sections are named according to the wrapper functions. Within each
 * section, the corresponding DWC_usb3 PCD function name is specified.
 *
 */

/**
 * This function is called by the Gadget Driver for each EP (except EP0) to
 * be configured for the current configuration (SET_CONFIGURATION).
 *
 * This function initializes the dwc_usb3_ep_t data structure, and then
 * calls dwc_usb3_ep_activate.
 */
int dwc_usb3_pcd_ep_enable(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			   const void *ep_desc)
{
	const usb_endpoint_descriptor_t *usb_ep_desc =
				(const usb_endpoint_descriptor_t *)ep_desc;
	int num, dir;
	unsigned short maxpacket;
	unsigned char type;
	unsigned char mult;

	pcd_debug("%s(%p,%p,%p)\n", __func__, pcd, ep, ep_desc);
	pcd_debug("ep=%p is_in=%d\n", ep, ep->dwc_ep.is_in);

	if (ep->dwc_ep.usb_ep_desc) {
		pcd_debug("%s, bad ep or descriptor!\n",
			   __func__);
		return -DWC_E_INVALID;
	}

	ep->dwc_ep.usb_ep_desc = usb_ep_desc;

	/*
	 * Activate the EP
	 */
	ep->dwc_ep.stopped = 0;

	num = UE_GET_ADDR(usb_ep_desc->bEndpointAddress);
	if (ep->dwc_ep.num != num) {
		pcd_debug( "%s, EP num mismatch, is %d asked %d!\n",
			   __func__, ep->dwc_ep.num, num);
	}

	dir = UE_GET_DIR(usb_ep_desc->bEndpointAddress);
	if (ep->dwc_ep.is_in != (dir == UE_DIR_IN)) {
		dwc_print3(pcd->usb3_dev,
			   "%s, EP dir mismatch, is %d asked %d!\n",
			   __func__, ep->dwc_ep.is_in, dir == UE_DIR_IN);
	}

	type = UE_GET_XFERTYPE(usb_ep_desc->bmAttributes);
	maxpacket = UGETW(usb_ep_desc->wMaxPacketSize);

	ep->dwc_ep.type = type;
	ep->dwc_ep.maxpacket = maxpacket & 0x7ff;
	ep->dwc_ep.intvl = 0;
	ep->dwc_ep.xfer_started = 0;

	switch (type) {
	case UE_INTERRUPT:
	case UE_ISOCHRONOUS:
		if (pcd->speed == USB_SPEED_SUPER) {
			ep->dwc_ep.intvl = usb_ep_desc->bInterval - 1;
			break;
		}

		ep->dwc_ep.intvl = usb_ep_desc->bInterval - 1;

		/*
		 * Bits 12:11 specify number of _additional_
		 * packets per microframe.
		 */
		mult = ((maxpacket >> 11) & 3) + 1;

		/* 3 packets at most */
		if (mult > 3)
			return -DWC_E_INVALID;

		ep->dwc_ep.mult = mult;
		break;
	}

	pcd_debug(
		   "type=%u maxpkt=%u mult=%u maxbst=%u numstrm=%u\n",
		   type, maxpacket, ep->dwc_ep.mult, ep->dwc_ep.maxburst,
		   ep->dwc_ep.num_streams);

	/* Set initial data PID. */
	if (ep->dwc_ep.type == UE_BULK)
		ep->dwc_ep.data_pid_start = 0;

	dwc_usb3_ep_activate(pcd, ep, 0);
	return 0;
}

/**
 * This function is called when an EP is disabled due to disconnect or
 * change in configuration. Any pending requests will terminate with a
 * status of -ESHUTDOWN.
 *
 * This function modifies the dwc_usb3_ep_t data structure for this EP,
 * and then calls ep_deactivate.
 */
int dwc_usb3_pcd_ep_disable(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_debug2(pcd->usb3_dev, "%s(%p)\n", __func__, ep);
	dwc_debug2(pcd->usb3_dev, "ep=%p is_in=%d\n", ep, ep->dwc_ep.is_in);

	if (!ep->dwc_ep.usb_ep_desc)
		return -DWC_E_INVALID;

	ep_deactivate(ep->dwc_ep.pcd, ep);

	//dwc_usb3_os_request_nuke(pcd, ep);
	
	ep->dwc_ep.desc_idx = 0;
	ep->dwc_ep.hiber_desc_idx = 0;
	ep->dwc_ep.usb_ep_desc = NULL;

	return 0;
}

/**
 * This function fills in an I/O Request for an EP.
 */
void dwc_usb3_pcd_fill_req(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			   dwc_usb3_pcd_req_t *req, int numbuf, void **buf,
			   dwc_dma_t *bufdma, unsigned int *buflen, unsigned int stream,
			   int req_flags)
{
	int i;

	pcd_debug( "req_flags=0x%1x\n", req_flags);

	req->dwc_req.length = 0;
	req->dwc_req.numbuf = numbuf;

	for (i = 0; i < numbuf; i++) {
		req->dwc_req.buf[i] = buf[i];
		req->dwc_req.bufdma[i] = bufdma[i];
		req->dwc_req.buflen[i] = buflen[i];
		req->dwc_req.length += buflen[i];
	}

	req->dwc_req.actual = 0;
	req->dwc_req.stream = stream;
	req->dwc_req.flags = req_flags;

	/* For EP0 IN without premature status, zlp is required? */
	if (ep == pcd->ep0 && ep->dwc_ep.is_in) {
		pcd_debug( "%d-OUT ZLP\n", ep->dwc_ep.num);
		//req->dwc_req.flags |= DWC_PCD_REQ_ZERO;
	}
}

/**
 * This function submits an I/O Request to an EP.
 *
 * - When the request completes the request's completion callback is called
 *   to return the request to the driver.
 * - An EP, except control EPs, may have multiple requests pending.
 * - Once submitted the request cannot be examined or modified.
 * - Each request is turned into one or more packets.
 * - A BULK EP can queue any amount of data; the transfer is packetized.
 * - Zero length Packets are specified with the request 'zero' flag.
 */
int dwc_usb3_pcd_ep_queue(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			  dwc_usb3_pcd_req_t *req, int req_flags, int q_empty)
{
	pcd_debug( "%s()\n", __func__);

	/* If queue is not empty, then don't start the transfer, unless this
	 * is an Isoc transfer
	 */
	if (!q_empty) {
		dwc_debug4(pcd->usb3_dev,
			   " q not empty %d, stopped %d, avail %d, istart %d\n",
			   pcd->request_pending, ep->dwc_ep.stopped,
			   ep->dwc_ep.desc_avail, ep->dwc_ep.xfer_started);

		if (!ep->dwc_ep.stopped && ep->dwc_ep.type == UE_ISOCHRONOUS &&
		    ep->dwc_ep.desc_avail > 0 && ep->dwc_ep.xfer_started)
			goto do_start;

	/* If EP is stopped, or there is no TRB available, or this is an Isoc
	 * transfer and the EP is not started, then don't start the transfer
	 */
	} else if (ep->dwc_ep.stopped ||
		   (ep != pcd->ep0 && ep->dwc_ep.desc_avail <= 0) ||
		   (ep->dwc_ep.type == UE_ISOCHRONOUS &&
		    !ep->dwc_ep.xfer_started)) {
		dwc_debug4(pcd->usb3_dev,
			   " q empty %d, stopped %d, avail %d, istart %d\n",
			   pcd->request_pending, ep->dwc_ep.stopped,
			   ep->dwc_ep.desc_avail, ep->dwc_ep.xfer_started);

	/* Start the transfer */
	} else {
		/* EP0 Transfer? */
		if (ep == pcd->ep0) {
			switch (pcd->ep0state) {
			case EP0_IN_DATA_PHASE:
				pcd_debug(
					   "%s ep0: EP0_IN_DATA_PHASE\n",
					   __func__);
				break;

			case EP0_OUT_DATA_PHASE:
				pcd_debug(
					   "%s ep0: EP0_OUT_DATA_PHASE\n",
					   __func__);
				if (pcd->request_config) {
					/* Complete STATUS PHASE */
					ep->dwc_ep.is_in = 1;
					pcd->ep0state = EP0_IN_WAIT_NRDY;
					return 1;
				}

				break;

			case EP0_IN_WAIT_GADGET:
				pcd_debug(
					   "%s ep0: EP0_IN_WAIT_GADGET\n",
					   __func__);
				pcd->ep0state = EP0_IN_WAIT_NRDY;
				return 2;

			case EP0_OUT_WAIT_GADGET:
				pcd_debug(
					   "%s ep0: EP0_OUT_WAIT_GADGET\n",
					   __func__);
				pcd->ep0state = EP0_OUT_WAIT_NRDY;
				return 3;

			case EP0_IN_WAIT_NRDY:
				pcd_debug(
					   "%s ep0: EP0_IN_WAIT_NRDY\n",
					   __func__);
				pcd->ep0state = EP0_IN_STATUS_PHASE;
				break;

			case EP0_OUT_WAIT_NRDY:
				pcd_debug(
					   "%s ep0: EP0_OUT_WAIT_NRDY\n",
					   __func__);
				pcd->ep0state = EP0_OUT_STATUS_PHASE;
				break;

			default:
				pcd_debug(
					   "%s ep0: odd state %d!\n",
					   __func__, pcd->ep0state);
				return -DWC_E_SHUTDOWN;
			}

			ep->dwc_ep.send_zlp = 0;

			if ((req_flags & DWC_PCD_REQ_ZERO) &&
			    req->dwc_req.length != 0 &&
			    (req->dwc_req.length &
			     (ep->dwc_ep.maxpacket - 1)) == 0) {
				ep->dwc_ep.send_zlp = 1;
			}

			dwc_usb3_ep0_start_transfer(pcd, req);

#ifdef DWC_STAR_9000463548_WORKAROUND
			if (pcd->configuring) {
				dwc_usb3_pcd_ep_t *ept;
				int i;

				pcd->configuring = 0;

				for (i = 0; i < pcd->num_in_eps; i++) {
					ept = pcd->in_ep[i];
					if (ept->dwc_ep.active)
						dwc_usb3_ep_activate
							(pcd, ept, 0);
				}

				for (i = 0; i < pcd->num_out_eps; i++) {
					ept = pcd->out_ep[i];
					if (ept->dwc_ep.active)
						dwc_usb3_ep_activate
							(pcd, ept, 0);
				}
			}
#endif
		} else {
			if (ep->dwc_ep.is_in &&
			    ep->dwc_ep.type == UE_BULK &&
			    pcd->usb3_dev->core_params->u1u2ctl &&
			    req->dwc_req.length == 13 &&				//	todo nemo	: length 13byte ????

		    	//USBC
			    //req->dwc_req.buf[0][0] == 0x55 &&
			    //req->dwc_req.buf[0][1] == 0x53 &&
			    //req->dwc_req.buf[0][2] == 0x42 &&	
			    //req->dwc_req.buf[0][3] == 0x53) {

				//#define FWDN_RESPONSE_SIGNATURE				0x52445746L		//"FWDR" ; FWDn Response
			    req->dwc_req.buf[0][0] == 0x52 &&
			    req->dwc_req.buf[0][1] == 0x55 &&
			    req->dwc_req.buf[0][2] == 0x57 &&
			    req->dwc_req.buf[0][3] == 0x46) {
				unsigned int dctl;

				/* If BOT CSW, enable U1/U2 entry */
				dctl = dwc_rd32(pcd->usb3_dev,
						&pcd->dev_global_regs->dctl);
				dctl |= DWC_DCTL_INIT_U1_EN_BIT |
					DWC_DCTL_INIT_U2_EN_BIT;
				dwc_wr32(pcd->usb3_dev,
					 &pcd->dev_global_regs->dctl, dctl);
			}
do_start:
			/* Setup and start the Transfer */
			dwc_usb3_ep_start_transfer(pcd, ep, req, 0);
		}
	}

	return 0;
}

/**
 * This function cancels an I/O request from an EP.
 */
void dwc_usb3_pcd_ep_dequeue(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			     dwc_usb3_pcd_req_t *req, unsigned int stream)
{
	dwc_debug4(pcd->usb3_dev, "%s(%p,%p) stream %d\n",
		   __func__, ep, req, stream);

	dwc_usb3_request_done(pcd, ep, req, -DWC_E_RESTART);
}

/**
 * usb_ep_set_halt stalls an endpoint.
 *
 * usb_ep_clear_halt clears an endpoint stall and resets its data toggle.
 *
 * Both of these functions are implemented with the same underlying function.
 * The behavior depends on the value argument.
 *
 * @param pcd    The PCD structure.
 * @param ep     The endpoint to set halt or clear halt.
 * @param value
 *	- 0 means clear_halt.
 *	- 1 means set_halt.
 *	- 2 means clear stall lock flag.
 *	- 3 means set stall lock flag.
 */
void dwc_usb3_pcd_ep_set_halt(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			      int value)
{
	pcd_debug( "%s(%p,%d)\n", __func__, ep, value);

	if (value == 0) {
		dwc_usb3_ep_clear_stall(pcd, ep);
		ep->dwc_ep.stopped = 0;

	} else if (value == 1) {
		if (ep->dwc_ep.is_in) {
			if (ep == pcd->ep0) {
				ep->dwc_ep.is_in = 0;
				dwc_usb3_ep_set_stall(pcd, ep);
				pcd->ep0state = EP0_STALL;
			} else {
				dwc_usb3_ep_set_stall(pcd, ep);
			}

			ep->dwc_ep.stopped = 1;
		} else {
			if (ep == pcd->ep0) {
				ep->dwc_ep.is_in = 0;
				dwc_usb3_ep_set_stall(pcd, ep);
				pcd->ep0state = EP0_STALL;
			} else {
				dwc_usb3_ep_set_stall(pcd, ep);
			}

			ep->dwc_ep.stopped = 1;
		}
	} else if (value == 2) {
		ep->dwc_ep.stall_clear_flag = 0;

	} else if (value == 3) {
		ep->dwc_ep.stall_clear_flag = 1;
	}
}

/**
 * This function completes a request. It calls the request callback.
 */
void dwc_usb3_request_done(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			   dwc_usb3_pcd_req_t *req, int status)
{
	unsigned stopped = ep->dwc_ep.stopped;

	dwc_debug4(pcd->usb3_dev, "%s(%p,%p,%d)\n", __func__, ep, req, status);

	if (ep != pcd->ep0 /*&&
	    (req->dwc_req.flags & DWC_PCD_REQ_STARTED)*/) {
		req->dwc_req.flags &= ~DWC_PCD_REQ_STARTED;
		if (req->dwc_req.trb)
			ep->dwc_ep.desc_avail++;
	}

	/* don't modify queue heads during completion callback */
	ep->dwc_ep.stopped = 1;

	if (ep != pcd->ep0)
		req->dwc_req.trb = NULL;

//	dwc_usb3_pcd_complete(pcd, ep, req, status);

	req->dwc_req.actual = 0;
	ep->dwc_ep.stopped = stopped;
}

/**
 * This function is called when the Device is disconnected. It stops any
 * active requests and informs the Gadget driver of the disconnect.
 */
void dwc_usb3_pcd_stop(dwc_usb3_pcd_t *pcd)
{
	dwc_usb3_pcd_ep_t *ep;
	dwc_usb3_dev_ep_regs_t   *ep_reg;
	int i;

	pcd_debug( "%s()\n", __func__);

	/* kill any outstanding requests, prevent new request submissions */
	for (i = 0; i < pcd->num_in_eps; i++) {
		ep = pcd->in_ep[i];
		if (ep->dwc_ep.active && ep->dwc_ep.tri_in) {
			ep_reg = ep->dwc_ep.in_ep_reg;
			ep->dwc_ep.condition = 0;
			dwc_usb3_dep_endxfer(pcd, ep_reg, ep->dwc_ep.tri_in, 1,
					     &ep->dwc_ep.condition);
			ep->dwc_ep.tri_in = 0;
		}

		//dwc_usb3_os_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
		ep->dwc_ep.desc_idx = 0;
		ep->dwc_ep.hiber_desc_idx = 0;
	}

	for (i = 0; i < pcd->num_out_eps; i++) {
		ep = pcd->out_ep[i];
		if (ep->dwc_ep.active && ep->dwc_ep.tri_out) {
			ep_reg = ep->dwc_ep.out_ep_reg;
			ep->dwc_ep.condition = 0;
			dwc_usb3_dep_endxfer(pcd, ep_reg, ep->dwc_ep.tri_out, 1,
					     &ep->dwc_ep.condition);
			ep->dwc_ep.tri_out = 0;
		}

		//dwc_usb3_os_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
		ep->dwc_ep.desc_idx = 0;
		ep->dwc_ep.hiber_desc_idx = 0;
	}

	/* don't disconnect drivers more than once */
	if (pcd->state == DWC_STATE_UNCONNECTED) {
		pcd_debug( "%s() Already Disconnected\n",
			   __func__);
		return;
	}

	pcd->state = DWC_STATE_UNCONNECTED;

	/* report disconnect; the driver is already quiesced */
	//dwc_usb3_pcd_disconnect(pcd);
}

/**
 * Gets the current USB frame number.
 */
int dwc_usb3_get_frame_number(dwc_usb3_pcd_t *pcd)
{
	return dwc_usb3_get_frame(pcd);
}

/**
 * Initialize the PCD EP structures to their default state.
 *
 * @param pcd  The PCD structure.
 */
static void pcd_epinit(dwc_usb3_pcd_t *pcd)
{
	int num_out_eps = pcd->num_out_eps;
	int num_in_eps = pcd->num_in_eps;
	int ep_cntr, i;
	dwc_usb3_pcd_ep_t *ep;

	dwc_debug2(pcd->usb3_dev, "%s(%p)\n", __func__, pcd);
	pcd_debug( "num_out_eps=%d\n", num_out_eps);
	pcd_debug( "num_in_eps=%d\n", num_in_eps);

	//=======================================================================
	// Initialize the EP0 structure
	//=======================================================================
	ep = pcd->ep0;

	/* Init EP structure */
	ep->dwc_ep.usb_ep_desc = NULL;
	ep->dwc_ep.dma_desc = NULL;
	ep->dwc_ep.pcd = pcd;
	ep->dwc_ep.stopped = 1;
	ep->dwc_ep.is_in = 0;
	ep->dwc_ep.active = 0;
	ep->dwc_ep.phys = 0;
	ep->dwc_ep.num = 0;
#ifdef DWC_UTE
	pcd->txf_map[1] = 0;
#endif
	ep->dwc_ep.tx_fifo_num = 0;
	ep->dwc_ep.out_ep_reg = &pcd->out_ep_regs[0];
	ep->dwc_ep.in_ep_reg = &pcd->in_ep_regs[0];

	ep->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
	ep->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
	ep->dwc_ep.send_zlp = 0;
	ep->dwc_ep.queue_sof = 0;

	pcd->ep0_req->dwc_req.buf[0] = NULL;
	pcd->ep0_req->dwc_req.bufdma[0] = 0;
	pcd->ep0_req->dwc_req.buflen[0] = 0;
	pcd->ep0_req->dwc_req.length = 0;
	pcd->ep0_req->dwc_req.actual = 0;

	//=======================================================================
	// Initialize the EP1-n structures
	//=======================================================================
	ep_cntr = 0;

	for (i = 1; ep_cntr < num_out_eps; i++) {
		dwc_debug2(pcd->usb3_dev,
			   "initializing EP%d-OUT (out_ep[%d])\n", i, ep_cntr);
		ep = pcd->out_ep[ep_cntr];
		ep_cntr++;

		/* Init EP structure */
		ep->dwc_ep.usb_ep_desc = NULL;
		ep->dwc_ep.dma_desc = NULL;
		ep->dwc_ep.pcd = pcd;
		ep->dwc_ep.stopped = 1;
		ep->dwc_ep.is_in = 0;
		ep->dwc_ep.active = 0;
		ep->dwc_ep.phys = ep_cntr << 1;
		ep->dwc_ep.num = 0;
		ep->dwc_ep.tx_fifo_num = 0;
		ep->dwc_ep.out_ep_reg = &pcd->out_ep_regs[ep_cntr];

		/* Control until EP is activated */
		ep->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
		ep->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
		ep->dwc_ep.send_zlp = 0;
		ep->dwc_ep.queue_sof = 0;
	}

	ep_cntr = 0;

	for (i = 1; ep_cntr < num_in_eps; i++) {
		dwc_debug2(pcd->usb3_dev,
			   "initializing EP%d-IN (in_ep[%d])\n", i, ep_cntr);
		ep = pcd->in_ep[ep_cntr];
		ep_cntr++;

		/* Init EP structure */
		ep->dwc_ep.usb_ep_desc = NULL;
		ep->dwc_ep.dma_desc = NULL;
		ep->dwc_ep.pcd = pcd;
		ep->dwc_ep.stopped = 1;
		ep->dwc_ep.is_in = 1;
		ep->dwc_ep.active = 0;
		ep->dwc_ep.phys = (ep_cntr << 1) | 1;
		ep->dwc_ep.num = 0;
#ifdef DWC_UTE
		pcd->txf_map[(ep_cntr << 1) | 1] = ep_cntr;
#endif
		ep->dwc_ep.tx_fifo_num = ep_cntr;
		ep->dwc_ep.in_ep_reg = &pcd->in_ep_regs[ep_cntr];

		/* Control until EP is activated */
		ep->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
		ep->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
		ep->dwc_ep.send_zlp = 0;
		ep->dwc_ep.queue_sof = 0;
	}

	pcd->ep0state = EP0_IDLE;
	pcd->ep0->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
	pcd->ep0->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
}

/**
 * Initialize the PCD portion of the driver.
 *
 */
int dwc_usb3_pcd_init(dwc_usb3_device_t *dev)
{
	dwc_usb3_pcd_t *pcd = &dev->pcd;

	dwc_debug1(dev, "%s()\n", __func__);

//	dev->pme_thread = kthread_run(dwc_wait_pme_thread, pcd, "pmethr");

	pcd->usb3_dev = dev;
	pcd->speed = 0; // unknown

	/*
	 * Initialize EP structures
	 */
	pcd_epinit(pcd);

	/*
	 * Initialize the Core (also enables interrupts and sets Run/Stop bit)
	 */
	dwc_usb3_core_device_init(dev, 1, 0);

	return 0;
}

/**
 * Cleanup the PCD portion of the driver.
 */
void dwc_usb3_pcd_remove(dwc_usb3_device_t *dev)
{
	dwc_debug1(dev, "%s()\n", __func__);

#if 0		/* 012.08.14 */
	if (dev->pme_thread) {
		kthread_stop(dev->pme_thread);
		dev->pme_thread = NULL;
	}
#endif /* 0 */

	dwc_usb3_core_device_remove(dev);
}
